\name{drFilter}
\alias{drFilter}
\title{Filter a 'ddo' or 'ddf' Object}
\usage{
drFilter(x, filterFn, output = NULL, overwrite = FALSE, params = NULL,
  control = NULL)
}
\arguments{
  \item{x}{an object of class 'ddo' or 'ddf'}

  \item{filterFn}{function that takes the keys and/or
  values and returns either \code{TRUE} or \code{FALSE} -
  if \code{TRUE}, that key-value pair will be present in
  the result}

  \item{output}{a "kvConnection" object indicating where
  the output data should reside (see
  \code{\link{localDiskConn}}, \code{\link{hdfsConn}}).  If
  \code{NULL} (default), output will be an in-memory "ddo"
  object.}

  \item{overwrite}{logical; should existing output location
  be overwritten? (also can specify \code{overwrite =
  "backup"} to move the existing output to _bak)}

  \item{params}{a named list of parameters external to the
  input data that are needed in the distributed computing
  (most should be taken care of automatically such that
  this is rarely necessary to specify)}

  \item{control}{parameters specifying how the backend
  should handle things (most-likely parameters to
  \code{rhwatch} in RHIPE) - see \code{\link{rhipeControl}}
  and \code{\link{localDiskControl}}}
}
\value{
a 'ddo' or 'ddf' object
}
\description{
Filter a 'ddo' or 'ddf' object
}
\examples{
bySpecies <- divide(iris, by = "Species")
drFilter(bySpecies, function(v) mean(v$Sepal.Width) < 3)
}
\author{
Ryan Hafen
}
\seealso{
\code{\link{drJoin}}, \code{\link{drLapply}}
}

